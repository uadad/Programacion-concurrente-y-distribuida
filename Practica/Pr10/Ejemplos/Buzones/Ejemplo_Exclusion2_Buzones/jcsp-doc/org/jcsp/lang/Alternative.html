<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_16) on Sun Jan 25 20:01:30 GMT 2009 -->
<TITLE>
Alternative (CSP for Java (JCSP) 1.1-rc4 API Specification (inc. Network))
</TITLE>

<META NAME="keywords" CONTENT="org.jcsp.lang.Alternative class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Alternative (CSP for Java (JCSP) 1.1-rc4 API Specification (inc. Network))";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>CSP for Java<br>(JCSP) 1.1-rc4</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../../org/jcsp/lang/AlternativeError.html" title="class in org.jcsp.lang"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/jcsp/lang/Alternative.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Alternative.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.jcsp.lang</FONT>
<BR>
Class Alternative</H2>
<PRE>
<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html" title="class or interface in java.lang">java.lang.Object</A>
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>org.jcsp.lang.Alternative</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>Alternative</B><DT>extends <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A></DL>
</PRE>

<P>
This enables a process to wait passively for and choose
 between a number of <A HREF="../../../org/jcsp/lang/Guard.html" title="class in org.jcsp.lang"><CODE>Guard</CODE></A> events.
 <P>
 <A HREF="#constructor_summary">Shortcut to the Constructor and Method Summaries.</A>
 <H2>Description</H2>
 The <code>Alternative</code> class enables a <code>CSProcess</code> to wait passively for and
 choose between a number of <A HREF="../../../org/jcsp/lang/Guard.html" title="class in org.jcsp.lang"><CODE>Guard</CODE></A> events.  This is known as
 <code>ALT</code><I>ing</I>.
 <P>
 <I>Note: for those familiar with the <I><B>occam</B></I> multiprocessing
 language, this gives the semantics of the </I><code>ALT</code><I> and
 </I><code>PRI</code> <code>ALT</code><I> constructs, extended with a built-in implementation
 of the classical </I><code>FAIR</code> <code>ALT</code><I>.</I>
 <P>
 The <code>Alternative</code> constructor takes an array of guards.  Processes
 that need to <I>Alt</I> over more than one set of guards will need a separate
 <code>Alternative</code> instance for each set.
 <P>
 Eight types of <code>Guard</code> are provided in <code>jcsp.lang</code>:
 <UL>
   <LI>
      <A HREF="../../../org/jcsp/lang/AltingChannelInput.html" title="class in org.jcsp.lang"><CODE>AltingChannelInput</CODE></A>: <I>object channel input</I> --
      ready if unread data is pending in the channel.
   <LI>
      <A HREF="../../../org/jcsp/lang/AltingChannelInputInt.html" title="class in org.jcsp.lang"><CODE>AltingChannelInputInt</CODE></A>: <I>integer channel input</I> --
      ready if unread data is pending in the channel.
   <LI>
      <A HREF="../../../org/jcsp/lang/AltingChannelOutput.html" title="class in org.jcsp.lang"><CODE>AltingChannelOutput</CODE></A>: <I>object channel output</I> --
      ready if a reading process can take the offered data
      (<A HREF="../../../org/jcsp/lang/One2OneChannelSymmetric.html" title="interface in org.jcsp.lang"><CODE><i>symmetric</i></CODE></A> channels only).
   <LI>
      <A HREF="../../../org/jcsp/lang/AltingChannelOutputInt.html" title="class in org.jcsp.lang"><CODE>AltingChannelOutputInt</CODE></A>: <I>integer channel output</I> --
      ready if a reading process can take the offered data
      (<A HREF="../../../org/jcsp/lang/One2OneChannelSymmetricInt.html" title="interface in org.jcsp.lang"><CODE><i>symmetric</i></CODE></A> channels only).
   <LI>
      <A HREF="../../../org/jcsp/lang/AltingChannelAccept.html" title="class in org.jcsp.lang"><CODE>AltingChannelAccept</CODE></A>: <I>CALL accept</I> --
      ready if an unaccepted call is pending.
   <LI>
      <A HREF="../../../org/jcsp/lang/AltingBarrier.html" title="class in org.jcsp.lang"><CODE>AltingBarrier</CODE></A>: <I>barrier synchronisation</I> --
      ready if all enrolled processes are offering to synchronise.
   <LI>
      <A HREF="../../../org/jcsp/lang/CSTimer.html" title="class in org.jcsp.lang"><CODE>CSTimer</CODE></A>: <I>timeout</I> --
      ready if the timeout has expired (timeout
      values are absolute time values, not delays)
   <LI>
      <A HREF="../../../org/jcsp/lang/Skip.html" title="class in org.jcsp.lang"><CODE>Skip</CODE></A>: <I>skip</I> --
      always ready.
 </UL>
 <P>
 By invoking one of the following methods, a process may passively wait for
 one or more of the guards associated with an <code>Alternative</code> object
 to become ready.  The methods differ in the way they choose which guard
 to select in the case when two or more guards are ready:
 <UL>
   <LI>
      <A HREF="../../../org/jcsp/lang/Alternative.html#select()"><CODE><code>select</code></CODE></A> waits for one or more of the guards
      to become ready.  If more than one become ready, it makes an
      <I>arbitrary</I> choice between them (and corresponds to the
      <I><B>occam</B></I> <code>ALT</code>).
   <LI>
      <A HREF="../../../org/jcsp/lang/Alternative.html#priSelect()"><CODE><code>priSelect</code></CODE></A> also waits for one or more of
      the guards to become ready.  However, if more than one becomes ready,
      it chooses the <I>first</I> one listed (and corresponds to the
      <I><B>occam</B></I> <code>PRI</code> <code>ALT</code>).  Note: the use of
      <code>priSelect</code> between channel inputs and a skip guard (at lowest
      priority) gives us a <I>polling</I> operation on the <I>readiness</I>
      of those channels.</I>
   <LI>
      <A HREF="../../../org/jcsp/lang/Alternative.html#fairSelect()"><CODE><code>fairSelect</code></CODE></A> also waits for one or more
      of the guards to become ready.  If more than one become ready, it
      prioritises its choice so that the guard it chose <I>the last time
      it was invoked</I> has lowest priority this time.  This corresponds
      to a common <I><B>occam</B></I> idiom used for real-time applications.
      If <code>fairSelect</code> is used
      in a loop, a ready guard has the guarantee that no other guard will be
      serviced <I>twice</I> before it will be serviced.  This enables
      an upper bound on service times to be calculated and ensures that no
      ready guard can be indefinitely starved.
 </UL>
 <P>
 Finally, each guard may be <A HREF="Alternative.html#Wot-no-Chickens">
 <I>pre-conditioned</I></A> with a run-time test
 to decide if it should be considered in the current choice.  This allows
 considerable flexibilty -- for example, we can decide whether timeouts
 shoud be set, channels refused or polling enabled depending
 on the run-time state of the <I>Alting</I> process.
 </P>
 <H2>Examples</H2>
 <H3>A Fair Multiplexor</H3>
 This example demonstrates a process that <I>fairly</I> multiplexes traffic
 from its array of input channels to its single output channel.  No input
 channel will be starved, regardless of the eagerness of its competitors.
 <PRE>
 import org.jcsp.lang.*;
 <I></I>
 public class FairPlex implements CSProcess {
 <I></I>
   private final AltingChannelInput[] in;
   private final ChannelOutput out;
 <I></I>
   public FairPlex (final AltingChannelInput[] in, final ChannelOutput out) {
     this.in = in;
     this.out = out;
   }
 <I></I>
   public void run () {
 <I></I>
     final Alternative alt = new Alternative (in);
 <I></I>
     while (true) {
       final int index = alt.fairSelect ();
       out.write (in[index].read ());
     }
 <I></I>
   }
 <I></I>
 }
 </PRE>
 Note that if <code>priSelect</code> were used above, higher-indexed channels would be
 starved if lower-indexed channels were continually demanding service.
 If <code>select</code> were used, no starvation analysis is possible.
 The <code>select</code> mechanism should only be used when starvation is not an issue.
 
 <H3><A NAME="FairMuxTime">A Fair Multiplexor with a Timeout and Poisoning</H3>
 This example demonstrates a process that <I>fairly</I> multiplexes traffic
 from its input channels to its single output channel, but which timeouts
 after a user-settable time.  Whilst running, no input channel
 will be starved, regardless of the eagerness of its competitors.
 The process also illustrates the poisoning of channels, following the timeout.
 <PRE>
 import org.jcsp.lang.*;
 
 public class FairPlexTime implements CSProcess {
 
   private final AltingChannelInput[] in;
   private final ChannelOutput out;
   private final long timeout;
 
   public FairPlexTime (final AltingChannelInput[] in, final ChannelOutput out,
                        final long timeout) {
     this.in = in;
     this.out = out;
     this.timeout = timeout;
   }
 
   public void run () {
 
     final Guard[] guards = new Guard[in.length + 1];
     System.arraycopy (in, 0, guards, 0, in.length);
 
     final CSTimer tim = new CSTimer ();
     final int timerIndex = in.length;
     guards[timerIndex] = tim;
 
     final Alternative alt = new Alternative (guards);
 
     boolean running = true;
     tim.setAlarm (tim.read () + timeout);
     while (running) {
       final int index = alt.fairSelect ();
       if (index == timerIndex) {
         running = false;
       } else {
         out.write (in[index].read ());
       }
     }
     System.out.println ("\n\r\tFairPlexTime: timed out ... poisoning all channels ...");
     for (int i = 0; i &lt; in.length; i++) {
       in[i].poison (42);                       // assume: channel immunity &lt; 42
     }
     out.poison (42);                           // assume: channel immunity &lt; 42
 
   }
 
 }
 </PRE>
 Note that if <code>priSelect</code> were used above, higher-indexed guards would be
 starved if lower-indexed guards were continually demanding service -- and
 the timeout would never be noticed.
 If <code>select</code> were used, no starvation analysis is possible.
 <P>
 Sometimes we need to use <code>priSelect</code> to impose a <I>specific</I>
 (as opposed to <I>fair</I>) choice that overcomes the external scheduling of events.
 For example, if we were concerned that the timeout above should
 be responded to <I>immediately</I> and unconcerned about the fair servicing of its
 channels, we should put its <code>CSTimer</code> as the first element of its <code>Guard</code>
 array and use <code>priSelect</code>.
 <P>
 To demonstrate <code>FairPlexTime</code>, consider:
 <PRE>
 import org.jcsp.lang.*;
 import org.jcsp.plugNplay.*;
 
 class FairPlexTimeTest {
 
   public static void main (String[] args) {
 
     final One2OneChannel[] a = Channel.one2OneArray (5, 0);     // poisonable channels (zero immunity)
     final One2OneChannel b = Channel.one2One (0);               // poisonable channels (zero immunity)

     final long timeout = 5000;                                  // 5 seconds
 
     new Parallel (
       new CSProcess[] {
         new Generate (a[0].out (), 0),
         new Generate (a[1].out (), 1),
         new Generate (a[2].out (), 2),
         new Generate (a[3].out (), 3),
         new Generate (a[4].out (), 4),
         new FairPlexTime (Channel.getInputArray (a), b.out (), timeout),
         new Printer (b.in (), "FairPlexTimeTest ==> ", "\n")
       }
     ).run ();
 
   }
 
 }
 </PRE>
 where <A HREF="../../../org/jcsp/plugNplay/Generate.html" title="class in org.jcsp.plugNplay"><CODE>Generate</CODE></A> sends its given <tt>Integer</tt> down its output channel
 as often as it can.
 This results in continuous demands on <tt>FairPlexTime</tt> by all its clients
 and demonstrates its fair servicing of those demands.
 <P>
 The <A HREF="../../../org/jcsp/plugNplay/Generate.html" title="class in org.jcsp.plugNplay"><CODE>Generate</CODE></A> and <A HREF="../../../org/jcsp/plugNplay/Printer.html" title="class in org.jcsp.plugNplay"><CODE>Printer</CODE></A> are
 programmed to deal with being poisoned.
 Here is the <tt>run()</tt> method for <tt>Generate</tt>:
 <PRE>
 public void run() {
   try {
     while (true) {
       out.write (N);
     }
   } catch (PoisonException p) {
     // the 'out' channel must have been posioned ... nothing left to do!
   }
 }
 </PRE>
 In general, there will be things to do &ndash; especially if there is more
 than one channel.
 For example, here is the <tt>catch</tt> block at the end of the <tt>run()</tt>
 method for <A HREF="../../../org/jcsp/plugNplay/Delta.html" title="class in org.jcsp.plugNplay"><CODE>Delta</CODE></A> (which has a single input channel-end,
 <tt>in</tt>, and an array of output channel-ends, <tt>out</tt>):
 <PRE>
   } catch (PoisonException p) {
     // don't know which channel was posioned ... so, poison them all!
     int strength = p.getStrength ();   // use same strength of poison
     in.poison (strength);
     for  (int i = 0; i &lt; out.length; i++) {
       out[i].poison (strength);
     }
   }
 </PRE>

 <H3><A NAME="STFR">A Simple Traffic Flow Regulator</H3>
 The <code>Regulate</code> process controls the rate of flow of traffic from its input
 to output channels.  It produces a constant rate of output flow, regardless of
 the rate of its input.  At the end of each timeslice defined by the required output
 rate, it outputs the last object input during that timeslice.  If nothing has come
 in during a timeslice, the previous output will be repeated (note: this will be a
 <code>null</code> if nothing has ever arrived).  If the input flow is greater than
 the required output flow, data will be discarded.
 <P>
 The interval (in msecs) defining the output flow rate is given by a constructor argument.
 This can be changed at any time by sending a new interval (as a <code>Long</code>)
 down the <code>reset</code> channel.
 <P>
 <I> Note: this example shows how simple it is to program time-regulated functionality
 like that performed by </I><code>java.awt.Component.repaint</code><I>.</I>
 <PRE>
 package org.jcsp.plugNplay;

 import org.jcsp.lang.*;
 
 public class Regulate implements CSProcess {
 
   private final AltingChannelInput in, reset;
   private final ChannelOutput out;
   private final long initialInterval;
 
   public Regulate (final AltingChannelInput in, final AltingChannelInput reset,
                    final ChannelOutput out, final long initialInterval) {
     this.in = in;
     this.reset = reset;
     this.out = out;
     this.initialInterval = initialInterval;
   }
 
   public void run () {
 
     final CSTimer tim = new CSTimer ();
 
     final Guard[] guards = {reset, tim, in};              // prioritised order
     final int RESET = 0;                                  // index into guards
     final int TIM = 1;                                    // index into guards
     final int IN = 2;                                     // index into guards
 
     final Alternative alt = new Alternative (guards);
 
     Object x = null;                                      // holding object
 
     long interval = initialInterval;
 
     long timeout = tim.read () + interval;
     tim.setAlarm (timeout);
 
     while (true) {
       switch (alt.priSelect ()) {
         case RESET:
           interval = ((Long) reset.read ()).longValue ();
           timeout = tim.read ();                          // fall through
         case TIM:
           out.write (x);
           timeout += interval;
           tim.setAlarm (timeout);
         break;
         case IN:
           x = in.read ();
         break;
       }
     }
 
   }
 
 }
 </PRE>
 <P>
 To demonstrate <code>Regulate</code>, consider:
 <PRE>
 class RegulateTest {
 
   public static void main (String[] args) {
 
     final One2OneChannel a = Channel.one2One ();
     final One2OneChannel b = Channel.one2One ();
     final One2OneChannel c = Channel.one2One ();
 
     final One2OneChannel reset = Channel.one2one (new OverWriteOldestBuffer (1));
 
     new Parallel (
       new CSProcess[] {
         new Numbers (a.out ()),                               // generate numbers
         new FixedDelay (250, a.in (), b.out ()),              // let them through every quarter second
         new Regulate (b.in (), reset.in (), c.out (), 1000),  // initially sample every second
         new CSProcess () {
           public void run () {
             Long[] sample = {new Long (1000), new Long (250), new Long (100)};
             int[] count = {10, 40, 100};
             while (true) {
               for (int cycle = 0; cycle < sample.length; cycle++) {
                 reset.write (sample[cycle]);
                 System.out.println ("\nSampling every " + sample[cycle] + " ms ...\n");
                 for (int i = 0; i < count[cycle]; i++) {
                   Integer n = (Integer) c.read ();
                   System.out.println ("\t==> " + n);
                 }
               }
             }
           }
         }
       }
     ).run ();
   }
 
 }
 </PRE>
 The reader may like to consider the danger of deadlock in the above system if
 the <code>reset</code> channel were not an <I>overwriting</I> one.

 <A NAME="Polling">
 <H3>Polling</H3>
 Sometimes, we want to handle incoming channel data if it's there, but get on with
 something else if all is quiet.  This can be done by <code>PRI</code> <code>ALT</code><I>ing</I>
 the channels we wish to poll against a <code>SKIP</code> guard:
 <PRE>
 import org.jcsp.lang.*;
 
 public class Polling implements CSProcess {
 
   private final AltingChannelInput in0;
   private final AltingChannelInput in1;
   private final AltingChannelInput in2;
   private final ChannelOutput out;
 
   public Polling (final AltingChannelInput in0, final AltingChannelInput in1,
                   final AltingChannelInput in2, final ChannelOutput out) {
     this.in0 = in0;
     this.in1 = in1;
     this.in2 = in2;
     this.out = out;
   }
 
   public void run() {
 
     final Skip skip = new Skip ();
     final Guard[] guards = {in0, in1, in2, skip};
     final Alternative alt = new Alternative (guards);
 
     while (true) {
       switch (alt.priSelect ()) {
         case 0:
           ...  process data pending on channel in0 ...
         break;
         case 1:
           ...  process data pending on channel in1 ...
         break;
         case 2:
           ...  process data pending on channel in2 ...
         break;
         case 3:
           ...  nothing available for the above ...
           ...  so get on with something else for a while ...
           ...  then loop around and poll again ...
         break;
       }
     }
 
   }
 
 }
 </PRE>
 The above technique lets us poll <I>any</I> <A HREF="../../../org/jcsp/lang/Guard.html" title="class in org.jcsp.lang"><CODE>Guard</CODE></A> events, including
 timeouts.  If we just want to poll <I>channels</I> for input events, see
 the <A HREF="../../../org/jcsp/lang/AltingChannelInput.html#pending()"><CODE>pending</CODE></A> methods of the various
 ``<TT>...2One...</TT>'' channels for a more direct and efficient way.
 <P>
 <I>Note: polling is an often overused technique.  Make sure your design would
 not be better suited with a blocking ALT and with the `something else' done by
 a process running in parallel.</I>

 <A NAME="Wot-no-Chickens">
 <H3>The <A HREF="http://wotug.org/parallel/groups/wotug/java/discussion/">`Wot-no-Chickens?'</A> Canteen</H3>
 This examples demonstrates the use of <I>pre-conditions</I> on the <code>ALT</code>
 guards.  The <code>Canteen</code> process buffers a supply of chickens.  It can
 hold a maximum of 20 chickens.  Chickens are supplied on the <code>supply</code>
 line in batches of, at most, 4.  Chickens are requested by hungry philosophers
 who share the <code>request</code> line to the <code>Canteen</code>.  In response to
 such requests, one chicken is delivered down the <code>deliver</code> line.
 <P>
 The <code>Canteen</code> refuses further supplies if it has no room for the maximum
 (4) batch supply.  The <code>Canteen</code> refuses requests from the philosophers
 if it has no chickens.
 <PRE>
 import org.jcsp.lang.*;
 
 public class Canteen implements CSProcess {
 
   private final AltingChannelInput supply;    // from the cook
   private final AltingChannelInput request;   // from a philosopher
   private final ChannelOutput deliver;        // to a philosopher
 
   public Canteen (final AltingChannelInput supply,
                   final AltingChannelInput request,
                   final ChannelOutput deliver) {
     this.supply = supply;
     this.request = request;
     this.deliver = deliver;
   }
 
   public void run() {
 
     final Guard[] guard = {supply, request};
     final boolean[] preCondition = new boolean[guard.length];
     final int SUPPLY = 0;
     final int REQUEST = 1;
 
     final Alternative alt = new Alternative (guard);
 
     final int maxChickens = 20;
     final int maxSupply = 4;
     final int limitChickens = maxChickens - maxSupply;
 
     final Integer oneChicken = new Integer (1);
     // ready to go!
 
     int nChickens = 0;
     // invariant : 0 <= nChickens <= maxChickens
 
     while (true) {
       preCondition[SUPPLY] = (nChickens <= limitChickens);
       preCondition[REQUEST] = (nChickens > 0);
       switch (alt.priSelect (preCondition)) {
         case SUPPLY:
           nChickens += ((Integer) supply.read ()).intValue ();  // <= maxSupply
         break;
         case REQUEST:
           Object dummy = request.read ();
           // we have to still input the signal
           deliver.write (oneChicken);
           // preCondition ==> (nChickens > 0)
           nChickens--;
         break;
       }
     }
 
   }
 
 }
 </PRE>
 <P>
 Contrast the above programming of the canteen as a CSP <I>process</I> rather
 than a <I>monitor</I>.  A monitor cannot refuse a callback when noone has the lock,
 even though it may not be in a state to process it.  In the above, a <code>supply</code>
 <I>method</I> would have to cope with its being called when there is no room to take the supply.
 A <code>request</code> <I>method</I> would have to be dealt with even though there may be no chickens
 to deliver.  Monitors manage such problems by putting their callers on hold
 (<code>wait</code>), but that means that their methods have to rely on each other to get
 out of any resulting embarassment (using <code>notify</code>).
 And that means that the logic of those methods has to be tightly coupled, which
 makes reasoning about them hard.  This gets worse the more interdependent methods
 the monitor has.
 <P>
 On the other hand, the above <code>Canteen</code> <I>process</I> simply refuses service on
 its <code>supply</code> and <code>request</code> <I>channels</I> if it can't cope, leaving
 the supplying or requesting processes waiting harmlessly on those channels.
 The service responses can assume their run-time set <I>pre-conditions</I> and have
 independent -- and trivial -- logic.  When circumstances permit,
 the blocked processes are serviced in the normal way.
 </P>
 <H2>Implementation Footnote</H2>
 This <code>Alternative</code> class and the various channel classes
 (e.g. <A HREF="../../../org/jcsp/lang/One2OneChannel.html" title="interface in org.jcsp.lang"><CODE>One2OneChannel</CODE></A>) are mutually dependent monitors -- they see instances
 of each other and invoke each others' strongly interdependent methods.  This logic
 is inspired by the published algorithms and data structures burnt into the microcode
 of the <I>transputer</I> some 15 years ago (1984).  Getting this logic <I>`right'</I>
 in the context of Java monitors is something we have done <code>(n + 1)</code> times,
 only to find it flawed <code>n</code> times with an unsuspected race-hazard months
 (sometimes years) later.  Hopefully, we have it <I>right</I> now ... but a proof
 of correctness is really needed!
 </P>
 To this end, a formal (CSP) model of Java's monitor primitives
 (the <code>synchronized</code> keyword and the <code>wait</code>, <code>notify</code> and
 <code>notifyAll</code> methods of the <code>Object</code> class) has been built.
 This has been used for the <I>formal verification</I> of the JCSP implementation
 of channel <code>read</code> and <code>write</code>, along with the correctness of
 <I>2-way</I> channel input <code>Alternative</code>s.
 Details and references are listed under
 <A HREF="http://www.cs.kent.ac.uk/projects/ofa/jcsp/index.html#Model"><I>`A CSP Model
 for Java Threads'</I> on the JCSP web-site</A>.
 [The proof uses the <A HREF="http://www.formal.demon.co.uk/FDR2.html">FDR</A>
 model checker.  Model checkers do not easily allow verification of results containing
 free variables - such as the correctness of the <I>n-way</I> <code>Alternative</code>.
 An investigation of this using <I>formal transformation</I> of one system of CSP equations
 into another, rather than <I>model checking</I> is being considered.]
 <P>
 The <I>transputer</I> designers always said that getting its microcoded scheduler
 logic right was one of their hardest tasks.  Working directly with the monitor
 concept means working at a similar level of difficulty for application programs.
 One of the goals of JCSP is to protect users from ever having to work at that level,
 providing instead a range of CSP primitives whose ease of use scales well with
 application complexity -- and in whose implementation those monitor complexities
 are correctly distilled and hidden.
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD>P.H. Welch and P.D. Austin</DD>
<DT><B>See Also:</B><DD><A HREF="../../../org/jcsp/lang/Guard.html" title="class in org.jcsp.lang"><CODE>Guard</CODE></A>, 
<A HREF="../../../org/jcsp/lang/AltingChannelInput.html" title="class in org.jcsp.lang"><CODE>AltingChannelInput</CODE></A>, 
<A HREF="../../../org/jcsp/lang/AltingChannelInputInt.html" title="class in org.jcsp.lang"><CODE>AltingChannelInputInt</CODE></A>, 
<A HREF="../../../org/jcsp/lang/AltingChannelAccept.html" title="class in org.jcsp.lang"><CODE>AltingChannelAccept</CODE></A>, 
<A HREF="../../../org/jcsp/lang/AltingBarrier.html" title="class in org.jcsp.lang"><CODE>AltingBarrier</CODE></A>, 
<A HREF="../../../org/jcsp/lang/CSTimer.html" title="class in org.jcsp.lang"><CODE>CSTimer</CODE></A>, 
<A HREF="../../../org/jcsp/lang/Skip.html" title="class in org.jcsp.lang"><CODE>Skip</CODE></A></DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jcsp/lang/Alternative.html#altMonitor">altMonitor</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The monitor synchronising the writers and alting reader</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../org/jcsp/lang/Alternative.html#Alternative(org.jcsp.lang.Guard[])">Alternative</A></B>(<A HREF="../../../org/jcsp/lang/Guard.html" title="class in org.jcsp.lang">Guard</A>[]&nbsp;guard)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Construct an <code>Alternative</code> object operating on the <A HREF="../../../org/jcsp/lang/Guard.html" title="class in org.jcsp.lang"><CODE>Guard</CODE></A>
 array of events.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jcsp/lang/Alternative.html#fairSelect()">fairSelect</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the index of one of the ready guards.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jcsp/lang/Alternative.html#fairSelect(boolean[])">fairSelect</A></B>(boolean[]&nbsp;preCondition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the index of one of the ready guards whose <code>preCondition</code> index
 is true.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jcsp/lang/Alternative.html#priSelect()">priSelect</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the index of one of the ready guards.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jcsp/lang/Alternative.html#priSelect(boolean[])">priSelect</A></B>(boolean[]&nbsp;preCondition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the index of one of the ready guards whose <code>preCondition</code>
 index is true.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jcsp/lang/Alternative.html#select()">select</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the index of one of the ready guards.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jcsp/lang/Alternative.html#select(boolean[])">select</A></B>(boolean[]&nbsp;preCondition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the index of one of the ready guards whose <code>preCondition</code>
 index is true.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#clone()" title="class or interface in java.lang">clone</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang">equals</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#finalize()" title="class or interface in java.lang">finalize</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#getClass()" title="class or interface in java.lang">getClass</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#hashCode()" title="class or interface in java.lang">hashCode</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#notify()" title="class or interface in java.lang">notify</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#notifyAll()" title="class or interface in java.lang">notifyAll</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#toString()" title="class or interface in java.lang">toString</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#wait()" title="class or interface in java.lang">wait</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#wait(long)" title="class or interface in java.lang">wait</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#wait(long, int)" title="class or interface in java.lang">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="altMonitor"><!-- --></A><H3>
altMonitor</H3>
<PRE>
protected <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A> <B>altMonitor</B></PRE>
<DL>
<DD>The monitor synchronising the writers and alting reader
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Alternative(org.jcsp.lang.Guard[])"><!-- --></A><H3>
Alternative</H3>
<PRE>
public <B>Alternative</B>(<A HREF="../../../org/jcsp/lang/Guard.html" title="class in org.jcsp.lang">Guard</A>[]&nbsp;guard)</PRE>
<DL>
<DD>Construct an <code>Alternative</code> object operating on the <A HREF="../../../org/jcsp/lang/Guard.html" title="class in org.jcsp.lang"><CODE>Guard</CODE></A>
 array of events.  Supported guard events are channel inputs
 (<A HREF="../../../org/jcsp/lang/AltingChannelInput.html" title="class in org.jcsp.lang"><CODE>AltingChannelInput</CODE></A> and <A HREF="../../../org/jcsp/lang/AltingChannelInputInt.html" title="class in org.jcsp.lang"><CODE>AltingChannelInputInt</CODE></A>),
 CALL channel accepts (<A HREF="../../../org/jcsp/lang/AltingChannelAccept.html" title="class in org.jcsp.lang"><CODE>AltingChannelAccept</CODE></A>),
 barriers (<A HREF="../../../org/jcsp/lang/AltingBarrier.html" title="class in org.jcsp.lang"><CODE>AltingBarrier</CODE></A>),
 timeouts (<A HREF="../../../org/jcsp/lang/CSTimer.html" title="class in org.jcsp.lang"><CODE>CSTimer</CODE></A>) and skips (<A HREF="../../../org/jcsp/lang/Skip.html" title="class in org.jcsp.lang"><CODE>Skip</CODE></A>).
 <P>
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>guard</CODE> - the event guards over which the select operations will be made.</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="select()"><!-- --></A><H3>
select</H3>
<PRE>
public final int <B>select</B>()</PRE>
<DL>
<DD>Returns the index of one of the ready guards. The method will block
 until one of the guards becomes ready.  If more than one is ready,
 an <I>arbitrary</I> choice is made.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="priSelect()"><!-- --></A><H3>
priSelect</H3>
<PRE>
public final int <B>priSelect</B>()</PRE>
<DL>
<DD>Returns the index of one of the ready guards. The method will block
 until one of the guards becomes ready.  If more than one is ready,
 the one with the lowest index is selected.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="fairSelect()"><!-- --></A><H3>
fairSelect</H3>
<PRE>
public final int <B>fairSelect</B>()</PRE>
<DL>
<DD>Returns the index of one of the ready guards. The method will block
 until one of the guards becomes ready.  Consequetive invocations will
 service the guards `fairly' in the case when many guards are always
 ready.  <I>Implementation note: the last guard serviced has the lowest
 priority next time around.</I>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="select(boolean[])"><!-- --></A><H3>
select</H3>
<PRE>
public final int <B>select</B>(boolean[]&nbsp;preCondition)</PRE>
<DL>
<DD>Returns the index of one of the ready guards whose <code>preCondition</code>
 index is true. The method will block until one of these guards becomes
 ready.  If more than one is ready, an <I>arbitrary</I> choice is made.
 <P>
 <I>Note: the length of the </I><code>preCondition</code><I> array must be the
 same as that of the array of guards with which this object was constructed.</I>
 <P>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>preCondition</CODE> - the guards from which to select</DL>
</DD>
</DL>
<HR>

<A NAME="priSelect(boolean[])"><!-- --></A><H3>
priSelect</H3>
<PRE>
public final int <B>priSelect</B>(boolean[]&nbsp;preCondition)</PRE>
<DL>
<DD>Returns the index of one of the ready guards whose <code>preCondition</code>
 index is true. The method will block until one of these guards becomes
 ready.  If more than one is ready, the one with the lowest index is selected.
 <P>
 <I>Note: the length of the </I><code>preCondition</code><I> array must be the
 same as that of the array of guards with which this object was constructed.</I>
 <P>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>preCondition</CODE> - the guards from which to select</DL>
</DD>
</DL>
<HR>

<A NAME="fairSelect(boolean[])"><!-- --></A><H3>
fairSelect</H3>
<PRE>
public final int <B>fairSelect</B>(boolean[]&nbsp;preCondition)</PRE>
<DL>
<DD>Returns the index of one of the ready guards whose <code>preCondition</code> index
 is true. The method will block until one of these guards becomes ready.
 Consequetive invocations will service the guards `fairly' in the case
 when many guards are always ready.  <I>Implementation note: the last
 guard serviced has the lowest priority next time around.</I>
 <P>
 <I>Note: the length of the </I><code>preCondition</code><I> array must be the
 same as that of the array of guards with which this object was constructed.</I>
 <P>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>preCondition</CODE> - the guards from which to select</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>CSP for Java<br>(JCSP) 1.1-rc4</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../../org/jcsp/lang/AlternativeError.html" title="class in org.jcsp.lang"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/jcsp/lang/Alternative.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Alternative.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size=\'-1\'><A HREF=\'mailto:jcsp-team@kent.ac.uk\'>Submit a bug or feature to jcsp-team@kent.ac.uk</A><br>Version 1.1-rc4 of the JCSP API Specification (Copyright 1997-2008 P.D.Austin and P.H.Welch - All Rights Reserved)<br>Java is a trademark or registered trademark of Sun Microsystems, Inc. in the US and other countries.
</BODY>
</HTML>
